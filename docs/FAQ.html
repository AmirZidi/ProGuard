<!doctype html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>ProGuard FAQ</title>
</head>
<body bgcolor="#ffffff">

<center><h2>Frequently Asked Questions</h2></center>

<table width="100%" cellpadding="5" cellspacing="0"><tr><td bgcolor="#EEEEFF">
<h3>Contents</h3>
</td></tr></table>

<ol>
<li><a href="#shrinking">What is shrinking?</a>
<li><a href="#obfuscation">What is obfuscation?</a>
<li><a href="#jdk1.4">Does <b>ProGuard</b> work with JDK1.4?</a>
<li><a href="#j2me">Does <b>ProGuard</b> work with J2ME?</a>
<li><a href="#forname">Does <b>ProGuard</b> handle <code>Class.forName</code>
    calls?</a>
<li><a href="#resource">Does <b>ProGuard</b> handle resource files?</a>
<li><a href="#ant">Does <b>ProGuard</b> have support for Ant?</a>
<li><a href="#gui">Does <b>ProGuard</b> come with a GUI?</a>
<li><a href="#stacktrace">Can <b>ProGuard</b> reconstruct obfuscated stack traces?</a>
</ol>

<a name="shrinking">&nbsp;</a>
<table width="100%" cellpadding="5" cellspacing="0"><tr><td bgcolor="#EEEEFF">
<h3>What is shrinking?</h3>
</td></tr></table>
<p>
Java source code (.java files) is typically compiled to bytecode (.class
files). Complete programs or program libraries are usually zipped up and
distributed as Java archives (.jar files). Bytecode is more compact than Java
source code, but it may still contain a lot of unused code, especially if it
uses program libraries. Shrinking programs such as <b>ProGuard</b> can analyze
bytecode and remove unused packages, classes, fields, and methods. The program
remains functionally equivalent, including the information given in exception
stack traces.

<p>
<a name="obfuscation">&nbsp;</a>
<table width="100%" cellpadding="5" cellspacing="0"><tr><td bgcolor="#EEEEFF">
<h3>What is obfuscation?</h3>
</td></tr></table>
<p>
By default, compiled bytecode still contains a lot of debugging information:
source file names, line numbers, field names, method names, argument names,
variable names, etc. This information makes it straightforward to decompile
the bytecode and reverse-engineer entire programs. Sometimes, this is not
desirable. Obfuscators such as <b>ProGuard</b> can remove the debugging
information and replace all names by meaningless character sequences, making
it much harder to reverse-engineer the code. It further compacts the code as a
bonus. The program remains functionally equivalent, except for the class
names, method names, and line numbers given in exception stack traces.

<p>
<a name="jdk1.4">&nbsp;</a>
<table width="100%" cellpadding="5" cellspacing="0"><tr><td bgcolor="#EEEEFF">
<h3>Does <b>ProGuard</b> work with JDK1.4?</h3>
</td></tr></table>
<p>
Yes. Class files compiled with the <code>javac</code> compiler of JDK1.4 are
targeted at JRE 1.2 by default. These class files have a slightly different
structure from older class files. The new class files fall within the original
Java bytecode specifications, so they will run on most virtual machines, but
they may trip some obfuscators. <b>ProGuard</b> handles both class file
structures correctly.

<p>
<a name="j2me">&nbsp;</a>
<table width="100%" cellpadding="5" cellspacing="0"><tr><td bgcolor="#EEEEFF">
<h3>Does <b>ProGuard</b> work with J2ME?</h3>
</td></tr></table>
<p>
Yes. <b>ProGuard</b> itself runs in J2SE, but you can freely specify the
run-time environment at which your programs are targeted, including J2ME. More
specifically, you'll specify <code>midpapi.zip</code> as the run-time library,
instead of J2SE's traditional <code>rt.jar</code>. All of <b>ProGuard</b>'s
powerful configuration options remain available. The <a
href="manual/examples.html">example section</a> of the <a
href="manual/index.html">ProGuard User Manual</a> illustrates how to process
<a href="manual/examples.html#midlet">a single midlet</a> or <a
href="manual/examples.html#midlets">all midlets</a> in your input jar, for
instance. In addition, <b>ProGuard</b> provides an obfuscator plug-in for the
J2ME Wireless Toolkit.

<p>
<a name="forname">&nbsp;</a>
<table width="100%" cellpadding="5" cellspacing="0"><tr><td bgcolor="#EEEEFF">
<h3>Does <b>ProGuard</b> handle <code>Class.forName</code> calls?</h3>
</td></tr></table>
<p>
Yes. <b>ProGuard</b> automatically handles
<code>Class.forName("SomeClass")</code> and <code>SomeClass.class</code>
constructs. The referenced classes are preserved in the shrinking phase, and
the string arguments are properly replaced in the obfuscation phase.
<p>
With variable string arguments, it's generally not possible to determine their
possible values. They might be read from a configuration file, for instance.
However, <b>ProGuard</b> will note constructs like
"<code>(SomeClass)Class.forName(variable).newInstance()</code>". These might
be an indication that the class or interface <code>SomeClass</code> and/or its
implementations may need to be preserved. The user can adapt his configuration
accordingly.

<p>
<a name="resource">&nbsp;</a>
<table width="100%" cellpadding="5" cellspacing="0"><tr><td bgcolor="#EEEEFF">
<h3>Does <b>ProGuard</b> handle resource files?</h3>
</td></tr></table>
<p>
Yes, in the sense that <b>ProGuard</b> copies all non-class resource files
from the given resource jars to the output jar. Their names and contents remain
unchanged.

<p>
<a name="ant">&nbsp;</a>
<table width="100%" cellpadding="5" cellspacing="0"><tr><td bgcolor="#EEEEFF">
<h3>Does <b>ProGuard</b> have support for Ant?</h3>
</td></tr></table>
<p>
Yes. <b>ProGuard</b> provides an Ant task, so that it integrates seamlessly
into your Ant build processes. You can still use configurations in
<b>ProGuard</b>'s own readable format. Alternatively, if you prefer XML, you
can specify the equivalent XML configuration.

<p>
<a name="gui">&nbsp;</a>
<table width="100%" cellpadding="5" cellspacing="0"><tr><td bgcolor="#EEEEFF">
<h3>Does <b>ProGuard</b> come with a GUI?</h3>
</td></tr></table>
<p>
No. <b>ProGuard</b> is a command-line tool. It can easily be integrated into
any automatic build process. Configuration is done using a few compact and
powerful options; just have a look at the examples in the <a
href="manual/index.html">ProGuard User Manual</a>. A graphical user interface
to help creating configuration files may be added in some future release.

<p>
<a name="stacktrace">&nbsp;</a>
<table width="100%" cellpadding="5" cellspacing="0"><tr><td bgcolor="#EEEEFF">
<h3>Can <b>ProGuard</b> reconstruct obfuscated stack traces?</h3>
</td></tr></table>
<p>
Yes. <b>ProGuard</b> comes with a companion tool, <b>ReTrace</b>, that can
'de-obfuscate' stack traces produced by obfuscated applications. The
reconstruction is based on the mapping file that <b>ProGuard</b> can write
out. If line numbers have been obfuscated away, a list of alternative method
names is presented for each obfuscated method name that has an ambiguous
reverse mapping. Please refer to the <a href="manual/index.html">ProGuard User
Manual</a> for more details.

<hr>
<address>
Copyright &copy; 2002-2003
<a href="http://www.graphics.cornell.edu/~eric/">Eric Lafortune</a>.
</address>
</body>
</html>
