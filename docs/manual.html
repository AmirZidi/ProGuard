<!doctype html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>ProGuard User Manual</title>
</head>
<body
 bgcolor="#ffffff"
 text="#000000">

<center><h1>ProGuard User Manual</h1></center>

<table width="100%" cellpadding="5" cellspacing="0"><tr><td bgcolor="#EEEEFF">
<h2>Contents</h2>
</td></tr></table>

<ol>
<li><a href="#introduction">Introduction</a>
<li><a href="#usage">Usage</a>
<li><a href="#limitations">Limitations</a>
<li><a href="#examples">Examples</a>
<li><a href="#troubleshooting">Troubleshooting</a>
</ol>
<p>
For a brief overview, please refer to the <a href="refcard.html">ProGuard
Reference Card</a>.
<p>
For restoring obfuscated stack traces, please refer to the <a
href="retrace.html">ReTrace User Manual</a>.
<p>

<a name="introduction">&nbsp;</a>
<table width="100%" cellpadding="5" cellspacing="0"><tr><td bgcolor="#EEEEFF">
<h2>Introduction</h2>
</td></tr></table>
<p>
<b>ProGuard</b> is a Java class file shrinker and obfuscator. It detects and
removes unused classes, fields, methods, and attributes, and it renames the
remaining classes, fields, and methods using short meaningless names. The
resulting jars are more compact and more difficult to reverse-engineer.
<p>
ProGuard can also be used to list unused fields and methods in an application,
and to print out the internal structure of class files.
<p>
ProGuard typically reads the input jars, shrinks their class files, obfuscates
the shrunk class files, and writes them to an output jar. In the shrinking
phase, one or more seed methods or classes are required. These seeds are
typically main methods and applets. The shrinker can then recursively
determine which classes and class members are used, and discard the rest. In
the obfuscation phase, all classes and class members get new names, except for
the seeds, so they can still be called by their original names.
<p>
ProGuard automatically handles <code>Class.forName("SomeClass")</code> and
<code>SomeClass.class</code> constructs. The referenced classes are preserved
in the shrinking phase, and the string arguments are properly replaced in the
obfuscation phase. With variable string arguments, it's generally not possible
to determine their possible values (they might be read from a configuration
file, for instance). However, ProGuard will note constructs like
"<code>(SomeClass)Class.forName(variable).newInstance()</code>". These might
be an indication that the class or interface <code>SomeClass</code> and/or its
implementations may need to be preserved. The user can adapt his configuration
accordingly.
<p>
<a name="usage">&nbsp;</a>
<table width="100%" cellpadding="5" cellspacing="0"><tr><td bgcolor="#EEEEFF">
<h2>Usage</h2>
</td></tr></table>
<p>
To run ProGuard, just type:
<p>
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<code><b>java -jar proguard.jar </b></code><i>options</i> ...
</td></tr></table>
<p>
Or, assuming the ProGuard jar is in your class path:
<p>
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<code><b>java proguard.ProGuard </b></code><i>options</i> ...
</td></tr></table>
<p>
Options can also be put in one or more configuration files. Typically, you'll
put most options in a configuration file, and just call:
<p>
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<code><b>
java -jar proguard.jar @myconfig.pro
</b></code>
</td></tr></table>
<p>
where <code>myconfig.pro</code> contains the actual options.
<p>
You can simply combine command line options and options from configuration
files, e.g.:
<p>
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<code><b>
java -jar proguard.jar @myconfig.pro -printusage -printmapping
</b></code>
</td></tr></table>
<p>
<p>
In a configuration file, a <code><b>#</b></code> sign and all remaining
characters on that line are ignored, allowing you to add comments.
<p>
Extra whitespace between words and delimiters is ignored. To specify file
names with spaces or special characters, or more exotically, to specify empty
class names, words can be quoted with single or double quotes. Note that the
quotes may need to be escaped when used on the command line of Unix systems,
to avoid gobbling by the shell.
<p>
Options can be grouped arbitrarily in arguments on the command line and in
lines in configuration files. This means that you can quote any arbitrary
section of command line options, to avoid shell expansion of special
characters, for instance.
<p>
The order of  the options is irrelevant. They can be abbreviated to their first
unique characters.
<p>
The following table lists all supported options.
<p>
<table cellspacing="10">
<tr>
<td valign="top"><code><b>@</b></code><i>filename</i></td>

<td>Short for '<code>-include</code> <i>filename</i>'.</td>

</tr>
<tr>
<td valign="top"><code><b>-include</b></code> <i>filename</i></td>

<td>Recursively reads configuration commands from the given file
    <i>filename</i>.</td>
</tr>
<tr>
<td valign="top"><code><b>-libraryjars</b></code>
    <i>jarname</i>[<b>:</b>...]</td>

<td>Specifies the library jars of the application to be processed. The class
    files in these jars will not be included in the output jar. The specified
    library jars should at least contain the class files that are
    <i>extended</i> by application class files. Library class files that are
    only <i>called</i> needn't be present. The jars can be specified with one
    or more <code>-libraryjars</code> directives. Multiple jars can also be
    specified using the path separator (e.g. ':' on Unix, or ';' on Windows
    platforms).
    <p>
    Please note that the boot path and class path set for running ProGuard are
    not considered when looking for library classes. This also means that you
    explicitly have to specify the run-time jar that your code will use.
    Although seemingly cumbersome, it allows you to process applications
    targeted at different run-time environments. For example, you can process
    <a href="#application">J2SE applications</a> as well as <a
    href="#midlet">J2ME midlets</a>, just by specifying the appropriate
    run-time jar.</td>

</tr>
<tr>
<td valign="top"><code><b>-injars</b></code> <i>jarname</i>[<b>:</b>...]</td>

<td>Specifies the program jars of the application to be processed. The class
    files in these jars will be processed and merged in the output jar. The
    jars can be specified with one or more <code>-injars</code> directives.
    Multiple jars can also be specified using the path separator (e.g. ':' on
    Unix, or ';' on Windows platforms).</td>

</tr>
<tr>
<td valign="top"><code><b>-outjar</b></code> <i>jarname</i></td>

<td>Specifies the name of the output jar. Without this directive, no jars will
    be written. With multiple directives, several identical copies of the
    output jar will be written.</td>

</tr>
<tr>
<td valign="top"><code><b>-keep</b></code> <i>class_specification</i></td>

<td>Specifies the classes and their class members to be preserved. They will
    be preserved with their original names. This is typically the required
    seed for recursively determining which other classes and class members
    need to be preserved. For example, in order to <a href="#application">keep
    an application</a>, you can specify the main class along with its main
    method. In order to <a href="#library">process a library</a>, you should
    specify all publicly accessible items.</td>

</tr>
<tr>
<td valign="top"><code><b>-keepclassmembers</b></code>
    <i>class_specification</i></td>

<td>Specifies any class members to be preserved, if their classes are
    preserved as well. For example, you may want to <a
    href="#serializable">keep all serialization fields and methods</a> of
    classes that implement the <code>Serializable</code> interface.</td>

</tr>
<tr>
<td valign="top"><code><b>-keepclasseswithmembers</b></code>
    <i>class_specification</i></td>

<td>Specifies the classes and their class members to be preserved, on the
    condition that all of the specified class members are present. For example,
    you may want to <a href="#applications">keep all applications</a> that have
    a main method, without having to list them explicitly.</td>

</tr>
<tr>
<td valign="top"><code><b>-keepnames</b></code>
    <i>class_specification</i></td>

<td>Specifies the classes and their class members whose names are to be
    preserved, if they aren't removed in the shrinking phase. For example, you
    may want to <a href="#serializable">keep all class names</a> of classes
    that implement the <code>Serializable</code> interface, so that the
    processed code remains compatible with any originally serialized classes.
    Classes that aren't used at all can still be removed.</td>

</tr>
<tr>
<td valign="top"><code><b>-keepclassmembernames</b></code>
    <i>class_specification</i></td>

<td>Specifies the class members whose the names are to be preserved, if they
    aren't removed in the shrinking phase. For example, you may want to
    <a href="#native">keep all method names</a> of native methods, so that
    the processed code can still link with the native library code. Native
    methods that aren't used at all can still be removed.</td>

</tr>
<tr>
<td valign="top"><code><b>-keepattributes</b></code>
    [<i>attribute_name<b>,</b>...</i>]</td>

<td>Specifies any optional attributes to be preserved. The attributes can be
    specified with one or more <code>-keepattributes</code> directives.
    Multiple attributes can also be specified separated by commas. An empty
    list or a <code><b>*</b></code> wildcard preserves all attributes. Typical
    optional attributes are <code>LineNumberTable</code>,
    <code>LocalVariableTable</code>, <code>SourceFile</code>,
    <code>Deprecated</code>, and <code>Synthetic</code>. The
    <code>InnerClasses</code> attribute name can be specified as well,
    referring to the source name part of this attribute. Only applicable when
    obfuscating.</td>

</tr>
<tr>
<td valign="top"><code><b>-renamesourcefileattribute</b></code>
    [<i>string</i>]</td>

<td>Specifies a constant string to be put in the <code>SourceFile</code>
    attributes of the class files. Note that the attribute also has to be
    preserved explicitly using the <code>-keepattributes</code> directive, or
    it will be removed anyway. For example, you may want to have your
    processed libraries and applications produce <a
    href="#stacktrace">useful obfuscated stack traces</a>. Only applicable when
    obfuscating.</td>

</tr>
<tr>
<td valign="top"><code><b>-printseeds</b></code><!--[<i>filename</i>]--></td>

<td>Specifies to exhaustively list classes and class members matched by the
    various <code>-keep</code> commands. The list is printed to the standard
    output<!--or to the given file-->. The list can be useful to verify if the
    intended class members are really found, especially if you're using
    wildcards. For example, you may want to list all the <a
    href="#applications">applications</a> or all the <a
    href="#applets">applets</a> that you are keeping.</td>

</tr>
<tr>
<td valign="top"><code><b>-printusage</b></code> [<i>filename</i>]</td>

<td>Specifies to list dead code of the input class files. The list is printed
    to the standard output or to the given file. For example, you can <a
    href="#deadcode">list the unused code of an application</a>. Only
    applicable when shrinking.</td>

</tr>
<tr>
<td valign="top"><code><b>-printmapping</b></code> [<i>filename</i>]</td>

<td>Specifies to print the mapping from old names to new names for classes and
    class members that have been renamed. The mapping is printed to the
    standard output or to the given file. Only applicable when
    obfuscating.</td>

</tr>
<tr>
<td valign="top"><code><b>-verbose</b></code></td>

<td>Specifies to write out some more information during processing. If the
    program terminates with an exception, this option will print out the entire
    stack trace, instead of just the exception message.</td>

</tr>
<tr>
<td valign="top"><code><b>-dump</b></code> [<i>filename</i>]</td>

<td>Specifies to write out the internal structure of the class files, after
    any processing. The structure is printed to the standard output or to the
    given file. For example, you may want to <a href="#structure">write out
    the contents of a given jar file</a>, without shrinking or obfuscating it
    first.</td>

</tr>
<tr>
<td valign="top"><code><b>-ignorewarnings</b></code></td>

<td>Specifies to print any warnings about unresolved references to
    superclasses, interfaces, or class members, but to continue processing in
    any case. If the classes or class members are indeed required for
    processing, the output jar will not function properly. Only use this
    option if you know what you're doing!</td>

</tr>
<tr>
<td valign="top"><code><b>-dontwarn</b></code></td>

<td>Specifies not to warn about unresolved references at all. Again, if the
    unresolved classes or class members are indeed required for processing,
    the output jar will not function properly. Only use this option if you
    know what you're doing!</td>

</tr>
<tr>
<td valign="top"><code><b>-dontnote</b></code></td>

<td>Specifies not to print notes about class casts of variable dynamically
    created objects. These notes provide hints about classes that may have to
    be kept.</td>

</tr>
<tr>
<td valign="top"><code><b>-dontshrink</b></code></td>

<td>Specifies not to shrink the input class files. By default, shrinking is
    applied: all classes and class members are removed, except for the ones
    listed by the various <code>-keep</code> commands, and the ones they
    depend on, recursively.</td>

</tr>
<tr>
<td valign="top"><code><b>-dontobfuscate</b></code></td>

<td>Specifies not to obfuscate the input class files. By default, obfuscation
    is applied: classes and class members receive new short random names,
    except for the ones listed by the various <code>-keep</code> commands.
    Internal attributes that are useful for debugging, such as source files
    names, variable names, and line numbers are removed.</td>

</tr>
<tr>
<td valign="top"><code><b>-overloadaggressively</b></code></td>

<td>Specifies to apply aggressive overloading while obfuscating. Multiple
    fields and methods can then get the same names, as long as their arguments
    and return types are different (not just their arguments, in the case of
    methods). This option can make the output jar even smaller (and less
    comprehensible). Only applicable when obfuscating.
    <p>
    Note that the resulting class files fall within the Java bytecode
    specification (cfr. <a href=
    "http://java.sun.com/docs/books/vmspec/2nd-edition/html/VMSpecTOC.doc.html"
    >The Java Virtual Machine Specification, Second Edition</a>, first
    paragraphs of <a href=
    "http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html#2877"
    >Section 4.5</a> and <a href=
    "http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html#1513"
    >Section 4.6</a>), even though this kind of overloading is not allowed in
    the Java language (cfr. <a href=
    "http://java.sun.com/docs/books/jls/second_edition/html/j.title.doc.html"
    >The Java Language Specification, Second Edition</a>, <a href=
    "http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#40898"
    >Section 8.3</a> and <a href=
    "http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#227768"
    >Section 8.4.7</a>). Still, some tools have problems with it. Most
    notably, Sun's JDK 1.2.2 javac compiler produces an exception when
    compiling with such a library (cfr. <a href=
    "http://developer.java.sun.com/developer/bugParade/bugs/4216736.html">Bug
    #4216736</a>). You therefore probably shouldn't use this option for
    processing libraries.</td>

</tr>
<tr>
<td valign="top"><code><b>-defaultpackage</b></code> [<i>package_name</i>]</td>

<td>Specifies to repackage all class files that are renamed into the single
    given package. Without argument or with an empty string (''), the package
    is removed completely. This option can make the output jar even smaller
    (and less comprehensible). Only applicable when obfuscating.
    <p>
    Note that this kind of repackaging may cause access permissions to become
    inconsistent, e.g. a class with default access may move to a different
    package from some other class that is using it. This may seem unusual, but
    it is formally allowed by Java's binary compatibility specifications (cfr.
    <a href=
    "http://java.sun.com/docs/books/jls/second_edition/html/j.title.doc.html"
    >The Java Language Specification, Second Edition</a>, <a href=
    "http://java.sun.com/docs/books/jls/second_edition/html/binaryComp.doc.html#47259"
    >Section 13.4.6</a>). Still, users have reported problems with applets in
    J2SE and with midlets J2ME. These environments don't seem to follow the
    compatibility specifications, strictly enforcing access permissions. When
    in doubt, just leave the packaging untouched by not using this option.</td>

</tr>
</table>
<p>
In the above table, <i>filename</i> and <i>jarname</i> can contain system
properties delimited by '<b>&lt;</b>' and '<b>&gt;</b>', e.g.
"<code>&lt;java.home&gt;</code>". The system property is automatically
replaced by its value. File names and jar names with special characters like
spaces and parentheses should be quoted with single or double quotes.
<p>
Furthermore, <i>class_specification</i> refers to a template of classes and
class members. The corresponding options are only applied to classes and class
members with matching templates. It was designed to look very Java-like, with
some extensions for wildcards:
<p>
<pre>
[[<b>!</b>]<b>public</b>|<b>final</b>|<b>abstract</b> ...] ([<b>!</b>]<b>interface</b>)|<b>class</b> <i>classname</i>
    [<b>extends</b>|<b>implements</b> <i>classname</i>]
[<b>{</b>
    [[<b>!</b>]<b>public</b>|<b>private</b>|<b>protected</b>|<b>static</b>|<b>volatile</b>|<b>transient</b> ...] <b>&lt;fields&gt;</b> |
                                                                (<i>fieldtype fieldname</i>)<b>;</b>
    [[<b>!</b>]<b>public</b>|<b>private</b>|<b>protected</b>|<b>static</b>|<b>synchronized</b>|<b>native</b>|<b>abstract</b>|<b>strictfp</b> ...] <b>&lt;methods&gt;</b> |
                                                                                   <b>&lt;init&gt;(</b><i>argumenttype,...</i><b>)</b> |
                                                                                   <i>classname</i><b>(</b><i>argumenttype,...</i><b>)</b> |
                                                                                   (<i>returntype methodname</i><b>(</b><i>argumenttype,...</i><b>)</b>)<b>;</b>
    [[<b>!</b>]<b>public</b>|<b>private</b>|<b>protected</b>|<b>static</b> ... ] <b>*;</b>
    ...
<b>}</b>]
</pre>
<p>
The above specification may look cluttered if your browser window isn't wide
enough. Square brackets "[]" mean that something is optional. Ellipsis dots
"..." mean that any number of items may be specified. A vertical bar "|"
indicates a choice between alternatives. Non-bold parentheses "()" just group
parts of the specification that belong together. The indentation tries to
clarify the intended meaning, but white-space is irrelevant in actual
configuration files.
<p>
<ul>

<li>The <code><b>class</b></code> keyword refers to any interface or class.
    The <code><b>interface</b></code> keyword restricts matches to interface
    classes. Preceding the <code><b>interface</b></code> keyword by a
    <code><b>!</b></code> restricts matches to classes that are not
    interfaces.
    <p>

<li>Every <i>classname</i> must be specified in full, e.g.
    <code>java.lang.String</code>. Class names may be specified as regular
    expressions containing the following wildcards:

<table cellspacing="10">

<tr><td valign="top"><code><b>?</b></code></td>

<td>matches any single character, but not the package separator. For example,
    "<code>mypackage.Test?</code>" matches "<code>mypackage.Test1</code>" and
    "<code>mypackage.Test2</code>", but not
    "<code>mypackage.Test12</code>".</td></tr>

<tr><td valign="top"><code><b>*</b></code></td>

<td>matches any string not containing the package separator. For example,
    "<code>mypackage.*Test*</code>" matches "<code>mypackage.Test</code>" and
    "<code>mypackage.YourTestApplication</code>", but not
    "<code>mypackage.mysubpackage.MyTest</code>". Or, more generally,
    "<code>mypackage.*</code>" matches all classes in
    "<code>mypackage</code>", but not in its subpackages.</td></tr>

<tr><td valign="top"><code><b>**</b></code></td>

<td>matches any string, possibly containing one or more package separators.
    For example, "<code>**.Test</code>"
    matches all <code>Test</code> classes in all packages except the root
    package. Or, "<code>mypackage.**</code>" matches all classes in
    "<code>mypackage</code>" and in its subpackages.</td></tr>

</table>

    For convenience and for backward compatibility, the class name
    <code><b>*</b></code> refers to any class, irrespective of its package.
    <p>

<li>The <code><b>extends</b></code> and <code><b>implements</b></code>
    specifications are typically used to restrict classes with wildcards. They
    are currently equivalent, specifying that only classes extending or
    implementing the given class qualify. Note that the given class itself is
    not included in this set. If required, it should be specified in a
    separate option.
    <p>

<li>Fields and methods are specified much like in Java, except that method
    argument lists don't contain argument names. The wildcard field name
    <code><b>&lt;fields&gt;</b></code> refers to any field. The wildcard
    method name <code><b>&lt;methods&gt;</b></code> refers to any method. The
    wildcard class member name <code><b>*</b></code> refers to any field or
    method. Note that all of the above wildcards don't have return types. More
    general regular expressions are not yet supported.
    <p>

<li>Constructors can be specified using their short class name (without
    package), using their full class name, or using the
    <code><b>&lt;init&gt;</b></code> wildcard. As in the Java language, the
    constructor specification has an argument list, but no return type.
    <p>

<li>The class access modifiers and class member access modifiers are typically
    used to restrict wildcard classes and class members. They specify that the
    corresponding access flags have to be set for the member to match. A
    preceding <code><b>!</b></code> specifies that the corresponding access
    flag should be unset.
    <p>
    Combining multiple flags is allowed (e.g. <code>public static</code>). It
    means that both access flags have to be set (e.g. <code>public</code>
    <i>and</i> <code>static</code>), except when they are conflicting, in
    which case at least one of them has to be set (e.g. at least
    <code>public</code>
    <i>or</i> <code>protected</code>).

</ul>

<a name="limitations">&nbsp;</a>
<table width="100%" cellpadding="5" cellspacing="0"><tr><td bgcolor="#EEEEFF">
<h2>Limitations</h2>
</td></tr></table>

<ul>
<li>ProGuard doesn't automatically preserve native method names, and private
    fields and methods that are part of the serialization API. You'll have to
    specify it in your configuration. It's quite simple; the example section
    below shows how.
    <p>

<li>ProGuard currently copies manifest files unchanged.
    <p>

<li>ProGuard currently ignores any resource files, images files, text
    files, etc. You should make sure your final application has all
    the files it needs, manually.
    <p>

<li>ProGuard's obfuscation process currently doesn't follow the naming rule
    specifying that internal classes must be named as
    <code>ExternalClass$InternalClass</code>, for instance (cfr. <a href=
    "http://java.sun.com/docs/books/jls/second_edition/html/j.title.doc.html"
    >The Java Language Specification, Second Edition</a>, <a href=
    "http://java.sun.com/docs/books/jls/second_edition/html/binaryComp.doc.html#59892"
    >Section 13.1</a>). This should not present a problem in practice, since
    the rule is mainly intended for transformations at the source code level.
    Internal-external class relationships are still represented correctly
    inside the binary class files. Decompilers or others tools that rely on
    the naming rule may have problems processing obfuscated jars.
    <p>

<li>ProGuard automatically detects <code>Class.forName</code> and
    <code>.class</code> constructs with constant classes. There is one caveat,
    however, when processing libraries that are to be used as such after
    obfuscation. The javac compiler compiles <code>.class</code> to a static
    method, <code>class$(String)</code>. This method calls
    <code>Class.forName</code> and returns a <code>Class</code> object,
    catching some exceptions along the way. ProGuard detects occurrences of
    the method. However, if you're using an obfuscated library, the
    <code>class$</code> method may have received a different name, thus
    escaping ProGuard's attention. The simple solution is to preserve the name
    of this method when obfuscating libraries, as illustrated in this <a
    href="#library">example</a>.
    <p>

<li>ProGuard may not handle obfuscation marker interfaces as expected. If you
    specify "<code>-keep class * implements MyKeepInterface</code>", and
    <code>MyKeepInterface</code> is not used in your code, the specified
    classes are kept, but they are obfuscated. Technically, the interface is
    removed in the shrinking phase, making the directive void in the
    obfuscation phase. This behavior may be fixed in the future. For now, you
    can get around it by explicitly keeping the interface as well:
    "<code>-keep class MyKeepInterface</code>". In any case, creating a proper
    configuration file seems a cleaner solution than using such an obfuscation
    marker interface.
</ul>

<a name="examples">&nbsp;</a>
<table width="100%" cellpadding="5" cellspacing="0"><tr><td bgcolor="#EEEEFF">
<h2>Examples</h2>
</td></tr></table>
<p>
Some typical useful configurations:
<ol>
<li><a href="#application">A typical application</a>
<li><a href="#applet">A typical applet</a>
<li><a href="#midlet">A typical midlet</a>
<li><a href="#applications">All possible applications in the input jars</a>
<li><a href="#applets">All possible applets in the input jars</a>
<li><a href="#midlets">All possible midlets in the input jars</a>
<li><a href="#servlets">All possible servlets in the input jars</a>
<li><a href="#library">Processing a library</a>
<li><a href="#native">Processing native methods</a>
<li><a href="#serializable">Processing serializable classes</a>
<li><a href="#beans">Processing bean classes</a>
<li><a href="#stacktrace">Producing useful obfuscated stack traces</a>
<li><a href="#deadcode">Finding dead code</a>
<li><a href="#structure">Printing out the internal structure of class files</a>
</ol>

<a name="application">&nbsp;</a>
<h3>A typical application</h3>
Shrink and obfuscate the ProGuard application itself:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-libraryjars &lt;java.home&gt;/lib/rt.jar
-injars      proguard.jar
-outjar      proguard_out.jar
-overloadaggressively
-defaultpackage ''

-keep public class proguard.ProGuard {
    public static void main(java.lang.String[]);
}
</pre>
</td></tr></table>
<p>
Note the use of the <code>&lt;java.home&gt;</code> system property; it is
replaced automatically.
<p>
Also note that the type names are fully specified:
<code>proguard.ProGuard</code> and <code>java.lang.String[]</code>.
<p>
The access modifiers <code>public</code> and <code>static</code> are not
really required in this case, since we know a priori that the specified class
and method have the proper access flags. It just looks more familiar this way.
<p>
We're using the <code>-overloadaggressively</code> and
<code>-defaultpackage</code> options to shave off some extra bytes, but we
could leave them out as well. The <code>-defaultpackage</code> directive moves
all classes to the given package, in this case the root package. Only
<code>proguard.ProGuard</code> keeps its original name.
<p>
In general, you might need a few additional directives for processing <a
href="#native">native methods</a>, <a href="#serializable">serializable
classes</a>, or <a href="#beans">bean classes</a>. For 'simple' applications
like ProGuard, that is not required.

<a name="applet">&nbsp;</a>
<h3>A typical applet</h3>
Shrink and obfuscate the applet <code>mypackage.MyApplet</code>:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-libraryjars &lt;java.home&gt;/lib/rt.jar
-injars      in.jar
-outjar      out.jar

-keep public class mypackage.MyApplet
</pre>
</td></tr></table>
<p>
The typical applet methods will be preserved automatically, since
<code>mypackage.MyApplet</code> is an extension of the <code>Applet</code>
class in the library <code>rt.jar</code>.
<p>
If applicable, you should add directives for processing <a
href="#native">native methods</a>, <a href="#serializable">serializable
classes</a>, or <a href="#beans">bean classes</a>.

<a name="midlet">&nbsp;</a>
<h3>A typical midlet</h3>
Shrink and obfuscate the J2ME midlet <code>mypackage.MyMIDlet</code>:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-libraryjars /usr/local/java/wtk104/lib/midpapi.zip
-injars      in.jar
-outjar      out.jar

-keep public class mypackage.MyMIDlet
</pre>
</td></tr></table>
<p>
Note how we're now targeting the J2ME run-time environment
<code>midpapi.zip</code>, instead of the J2SE run-time environment
<code>rt.jar</code>.
<p>
The typical midlet methods will be preserved automatically, since
<code>mypackage.MyMIDlet</code> is an extension of the <code>MIDlet</code>
class in the library <code>midpapi.zip</code>.
<p>
If applicable, you should add directives for processing <a
href="#native">native methods</a>, <a href="#serializable">serializable
classes</a>, or <a href="#beans">bean classes</a>.
<p>
Please note the in-depth article <a
href="http://wireless.java.sun.com/midp/ttips/proguard/">"Obfuscating MIDlet
Suites with ProGuard"</a> at <a
href="http://wireless.java.sun.com/">wireless.java.sun.com</a>.

<a name="applications">&nbsp;</a>
<h3>All possible applications in the input jars</h3>
Shrink and obfuscate all public applications in <code>in.jar</code>:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-libraryjars &lt;java.home&gt;/lib/rt.jar
-injars      in.jar
-outjar      out.jar
-printseeds

-keepclasseswithmembers public class * {
    public static void main(java.lang.String[]);
}
</pre>
</td></tr></table>
<p>
Note the use of <code>-keepclasseswithmembers</code>. We don't want to preserve
all classes, just all classes that have main methods, and those methods.
<p>
The <code>-printseeds</code> option prints out which classes exactly will
be preserved, so we know for sure we're getting what we want.
<p>
If applicable, you should add directives for processing <a
href="#native">native methods</a>, <a href="#serializable">serializable
classes</a>, or <a href="#beans">bean classes</a>.

<a name="applets">&nbsp;</a>
<h3>All possible applets in the input jars</h3>
Shrink and obfuscate all public applets in <code>in.jar</code>:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-libraryjars &lt;java.home&gt;/lib/rt.jar
-injars      in.jar
-outjar      out.jar
-printseeds

-keep public class * extends java.applet.Applet
</pre>
</td></tr></table>
<p>
We're simply keeping all classes that extend the <code>Applet</code> class.
<p>
Again, the <code>-printseeds</code> option prints out which applets exactly
will be preserved.
<p>
If applicable, you should add directives for processing <a
href="#native">native methods</a>, <a href="#serializable">serializable
classes</a>, or <a href="#beans">bean classes</a>.

<a name="midlets">&nbsp;</a>
<h3>All possible midlets in the input jars</h3>
Shrink and obfuscate all public J2ME midlets in <code>in.jar</code>:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-libraryjars /wtk104/lib/midpapi.zip
-injars      in.jar
-outjar      out.jar
-printseeds

-keep public class * extends javax.microedition.midlet.MIDlet
</pre>
</td></tr></table>
<p>
We're simply keeping all classes that extend the <code>MIDlet</code> class.
<p>
And again, the <code>-printseeds</code> option prints out which midlets exactly
will be preserved.
<p>
If applicable, you should add directives for processing <a
href="#native">native methods</a>, <a href="#serializable">serializable
classes</a>, or <a href="#beans">bean classes</a>.

<a name="servlets">&nbsp;</a>
<h3>All possible servlets in the input jars</h3>
Shrink and obfuscate all public servlets in <code>in.jar</code>:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-libraryjars &lt;java.home&gt;/lib/rt.jar
-libraryjars /usr/local/java/servlet/servlet.jar
-injars      in.jar
-outjar      out.jar
-printseeds

-keep public class * implements javax.servlet.Servlet
</pre>
</td></tr></table>
<p>
Keeping all servlets is very similar to keeping all applets. The servlet API
is not part of the standard run-time jar, so we're specifying it as a library.
Don't forget to use the right path name.
<p>
We're then keeping all classes that implement the <code>Servlet</code>
interface. We're using the <code>implements</code> keyword because it looks
more familiar in this context, but it is equivalent to <code>extends</code>,
as far as ProGuard is concerned.
<p>
And again, the <code>-printseeds</code> option prints out which servlets
exactly will be preserved.
<p>
If applicable, you should add directives for processing <a
href="#native">native methods</a>, <a href="#serializable">serializable
classes</a>, or <a href="#beans">bean classes</a>.

<a name="library">&nbsp;</a>
<h3>Processing a library</h3>
Shrink and obfuscate an entire library, keeping all public and
protected classes and class members, native method names, and serialization
code:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-libraryjars  &lt;java.home&gt;/lib/rt.jar
-injars       in.jar
-outjar       out.jar
-printmapping out.map

-renamesourcefileattribute SourceFile
-keepattributes SourceFile,LineNumberTable

-keep public class * {
    public protected *;
}

-keepclassmembernames class * {
    native &lt;methods&gt;;
    static Class class$(java.lang.String);
}

-keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    Object writeReplace();
    Object readResolve();
}
</pre>
</td></tr></table>
<p>
This configuration should preserve everything we'll ever want to access in the
library. Only if there are any other non-public classes or methods that are
invoked dynamically, they should be specified using additional
<code>-keep</code> directives.
<p>
Note the use of <code>-keepclassmembernames</code> for the static
<code>class$</code> method. This method is inserted by the javac compiler to
implement the <code>.class</code> construct. ProGuard will automatically
detect it and deal with it; no problem at this point. However, ProGuard may be
used again to shrink an application that uses this obfuscated library. Without
having preserved the method's name, the automatic detection would fail this
second time around.
<p>
We've added some directives for <a href="#stacktrace">useful stack traces</a>,
for <a href="#native">native methods</a>, and for <a
href="#serializable">serializable classes</a>, which are discussed in their
respective examples.

<a name="native">&nbsp;</a>
<h3>Processing native methods</h3>
If your application, applet, servlet, library, etc., contains native methods,
you'll want to preserve their names, so they can still be linked to the native
library. The following additional directives will ensure that:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-keepclassmembernames class * {
    native &lt;methods&gt;;
}
</pre>
</td></tr></table>
<p>
Note the use of <code>-keepclassmembernames</code>. We don't want to preserve
all classes or all native methods; we just want to keep all native method
names from being obfuscated.

<a name="serializable">&nbsp;</a>
<h3>Processing serializable classes</h3>
More complex applications, applets, servlets, libraries, etc., may contain
classes that are serialized. Depending on the way in which they are used, they
may require special attention:
<ul>

<li>Often, serialization is simply a means of transporting data, without
    long-term storage. Classes that are shrunk and obfuscated should then
    continue to function fine with the following additional directives:

<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-keepclassmembers class * implements java.io.Serializable {
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    Object writeReplace();
    Object readResolve();
}
</pre>
</td></tr></table>
<p>

    The <code>-keepclassmembers</code> option makes sure that any
    serialization methods are kept. By using this directive instead of the
    basic <code>-keep</code> directive, we're not forcing preservation of
    <i>all</i> serializable classes, just preservation of the listed members
    of classes that are actually used.
    <p>

<li>Sometimes, the serialized data are stored, and read back later into newer
    versions of the serializable classes. One then has to take care the classes
    remain compatible with their unprocessed versions and with future
    processed versions. In such cases, the relevant classes will most likely
    have <code>serialVersionUID</code> fields. The following directives should
    then be sufficient to ensure compatibility over time:

<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-keepnames class * implements java.io.Serializable

-keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
    !static !transient &lt;fields&gt;;
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    Object writeReplace();
    Object readResolve();
}
</pre>
</td></tr></table>
<p>

    The <code>serialVersionUID</code> line makes sure that field is preserved.
    The <code>&lt;fields&gt;</code> line preserves all non-static,
    non-transient fields, with their original names. The introspection of the
    serialization process and the de-serialization process will then find
    consistent names.

<li>Occasionally, the serialized data have to remain compatible, but the
    classes involved lack <code>serialVersionUID</code> fields. I imagine the
    original code will then be hard to maintain, since the serial version UID
    is then computed from a list of features the serializable class. Changing
    the class ever so slightly may change the computed serial version UID. The
    list of features is specified in the chapter on <a
    href="http://java.sun.com/j2se/1.4/docs/guide/serialization/spec/class.doc6.html">Stream
    Unique Identifiers</a> of Sun's <a
    href="http://java.sun.com/j2se/1.4/docs/guide/serialization/">Object
    Serialization Guide</a>. The following directives should at least
    partially ensure compatibility with the original classes

<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-keepnames class * implements java.io.Serializable

-keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
    !static !transient &lt;fields&gt;;
    !private &lt;fields&gt;;
    !private &lt;methods&gt;;
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    Object writeReplace();
    Object readResolve();
}
</pre>
</td></tr></table>
<p>

    The new directives force preservation of the elements involved in the UID
    computation. In addition, the user will have to manually specify all
    interfaces of the serializable classes (using something like "<code>-keep
    interface MyInterface</code>"), since these names are also used when
    computing the UID. A fast but sub-optimal alternative would be simply
    keeping all interfaces with "<code>-keep interface *</code>".

</ul>
<p>

Note that the above directives may preserve more classes and class members
than strictly necessary. For instance, a large number of classes may implement
the <code>Serialization</code> interface, yet only a small number may actually
ever be serialized. Knowing your application and tuning the configuration will
often produce more compact results.

<a name="beans">&nbsp;</a>
<h3>Processing bean classes</h3>
If your application, applet, servlet, library, etc., uses extensive
introspection on bean classes to find bean editor classes, or getter and
setter methods, then configuration may become laborious. There's not much else
you can do than making sure the bean class names, or the getter and setter
names don't change. For instance:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-keep public class mypackage.MyBean {
    public void setMyProperty(int);
    public int getMyProperty();
}

-keep public class mypackage.MyBeanEditor
</pre>
</td></tr></table>

<a name="stacktrace">&nbsp;</a>
<h3>Producing useful obfuscated stack traces</h3>
These configuration directives specify to rename the source file attributes,
and to keep the line number table attributes of all obfuscated class files:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-printmapping out.map

-renamesourcefileattribute SourceFile
-keepattributes SourceFile,LineNumberTable
</pre>
</td></tr></table>
<p>
We're keeping all source file attributes, but we're replacing them by the
string "SourceFile". We could use any string, but this string is already
present in all class files, so it doesn't take up any extra space.
<p>
We're also keeping the line number tables of all methods.
<p>
Whenever both of these attributes are present, the Java run-time environment
will include line number information when printing out exception stack traces.
<p>
The information will only be useful if we can map the obfuscated names back to
their original names, so we're saving the mapping to a file
<code>out.map</code>. The information can then be used by the <a
href="retrace.html">ReTrace</a> tool to restore the original stack trace.

<a name="deadcode">&nbsp;</a>
<h3>Finding dead code</h3>
List unused fields and methods in the application
<code>mypackage.MyApplication</code>:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-libraryjars &lt;java.home&gt;/lib/rt.jar
-injars      in.jar
-dontobfuscate
-printusage

-keep public class mypackage.MyApplication {
    public static void main(java.lang.String[]);
}
</pre>
</td></tr></table>
<p>
We're not specifying an output jar, just printing out some results.
<p>
We're saving a little bit of time by not passing through the obfuscation phase.

<a name="structure">&nbsp;</a>
<h3>Printing out the internal structure of class files</h3>
Print out the internal structure of all class files in the input jar:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-injars in.jar
-dontwarn
-dontnote
-dontshrink
-dontobfuscate
-dump
</pre>
</td></tr></table>
<p>
Note how we don't need to specify the Java run-time jar, because we're not
processing the input jar at all. In this case, we can safely ignore any
warnings about unresolved references, so we use the <code>-dontwarn</code>
option. We're also not interested in any advice about dynamic invocations,
so we use the <code>-dontnote</code> option.

<p>
<a name="troubleshooting">&nbsp;</a>
<table width="100%" cellpadding="5" cellspacing="0"><tr><td bgcolor="#EEEEFF">
<h2>Troubleshooting</h2>
</td></tr></table>
<p>
ProGuard may print out some notes:
<ul>
<li>If your code contains <b>class casts of dynamically created class
    instances</b>, like
    "<code>(MyClass)Class.forName(variable).newInstance()</code>", ProGuard
    will list them. Depending on your application, you may need to keep the
    mentioned classes with something like "<code>-keep class MyClass</code>",
    or their implementations with something like "<code>-keep class *
    implements MyClass</code>". You can switch off these notes by specifying
    the <code>-dontnote</code> option.
</ul>
<p>
ProGuard may terminate with warnings in a couple of cases:
<ul>
<li>If there are <b>unresolved references to superclasses or interfaces</b>,
    you most likely forgot to specify an essential library. At least the Java
    run-time library should be specified. Furthermore, all libraries with
    classes or interfaces that are extended or implemented by classes in your
    input jars should be specified. If you're missing a library and you're
    absolutely sure it isn't used anyway, you can try your luck with the
    <code>-ignorewarnings</code> option, or even the <code>-dontwarn</code>
    option.
    <p>

<li>If there are <b>unresolved references to class members in input
    classes</b>, your class files are most likely inconsistent. Possibly, some
    class file didn't get recompiled properly, or some class file was left
    behind after its source file was removed. Try removing all class files,
    recompiling them, zipping them up, and running ProGuard again.
</ul>
<p>
If ProGuard runs fine, but your processed application doesn't work, there
might be several reasons:
<ul>
<li>If you get a <code><b>ClassNotFoundException</b></code>, your code is
    probably calling <code>Class.forName</code>, trying to create the missing
    class dynamically. ProGuard can only detect constant name arguments, like
    <code>Class.forName("mypackage.MyClass")</code>. For variable name
    arguments like <code>Class.forName(someClass)</code>, you have to keep all
    possible classes using the <code>-keep</code> option, e.g. "<code>-keep
    class mypackage.MyClass</code>" or "<code>-keep class * implements
    mypackage.MyInterface</code>".
    <p>

<li>If you get a <code><b>NoSuchMethodError</b></code>, your code is probably
    calling something like <code>myClass.getMethod</code>, trying to find some
    method dynamically. Since ProGuard isn't detecting this (yet), you have to
    keep the missing method in using the <code>-keep</code> option, e.g.
    "<code>-keep class mypackage.MyClass { void myMethod(); }</code>".
    <p>

<li>If you get a <code><b>NullPointerException</b></code> or if you don't see
    any icons, your processed code may be missing some resource files. Please
    remember that ProGuard currently ignores all non-<code>.class</code> files
    in the input jars. You should add image files, sound files, text files,
    etc. manually to the output jars or to some support jars.
    <p>

<li>If you get an <code><b>AbstractMethodError</b></code>, perhaps there's a
    bug in ProGuard (gasp!). If so, please contact me, preferably with the
    simplest example on which you can find ProGuard to fail.
</ul>
<p>

Should ProGuard crash while processing your application:
<ul>
<li>Maybe your class files are corrupt. See if recompiling them and trying
    again helps. If not, please contact me, at least reporting the version of
    your JDK, the version of ProGuard, the options, and the printed output,
    including exception stack trace (use the <code>-verbose</code> option).
</ul>
<p>

<hr>
<address>
Copyright &copy; 2002 <a href="http://www.graphics.cornell.edu/~eric/">Eric
Lafortune</a>.
</address>
</body>
</html>
