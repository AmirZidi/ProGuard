<!doctype html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>ProGuard Examples</title>
</head>
<body
 bgcolor="#ffffff"
 text="#000000">

<table width="100%" cellpadding="10" cellspacing="0"><tr><th bgcolor="#EEEEFF">
<font size="+2">Examples</font>
</th></tr></table>
<p>

Some typical useful configurations:
<ol>
<li><a href="#application">A typical application</a>
<li><a href="#applet">A typical applet</a>
<li><a href="#midlet">A typical midlet</a>
<li><a href="#applications">All possible applications in the input jars</a>
<li><a href="#applets">All possible applets in the input jars</a>
<li><a href="#midlets">All possible midlets in the input jars</a>
<li><a href="#servlets">All possible servlets in the input jars</a>
<li><a href="#library">Processing a library</a>
<li><a href="#native">Processing native methods</a>
<li><a href="#serializable">Processing serializable classes</a>
<li><a href="#beans">Processing bean classes</a>
<li><a href="#stacktrace">Producing useful obfuscated stack traces</a>
<li><a href="#deadcode">Finding dead code</a>
<li><a href="#structure">Printing out the internal structure of class files</a>
</ol>

<a name="application">&nbsp;</a>
<h3>A typical application</h3>
To shrink and obfuscate the ProGuard application itself, one would typically
create a configuration file <code>proguard.pro</code> and then type:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<code>java -jar proguard.jar @proguard.pro</code>
</td></tr></table>
<p>

The configuration file would contain the following options:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-libraryjars &lt;java.home&gt;/lib/rt.jar
-injars      proguard.jar
-outjar      proguard_out.jar
-overloadaggressively
-defaultpackage ''

-keep public class proguard.ProGuard {
    public static void main(java.lang.String[]);
}
</pre>
</td></tr></table>
<p>
Note the use of the <code>&lt;java.home&gt;</code> system property; it is
replaced automatically.
<p>
Also note that the type names are fully specified:
<code>proguard.ProGuard</code> and <code>java.lang.String[]</code>.
<p>
The access modifiers <code>public</code> and <code>static</code> are not
really required in this case, since we know a priori that the specified class
and method have the proper access flags. It just looks more familiar this way.
<p>
We're using the <code>-overloadaggressively</code> and
<code>-defaultpackage</code> options to shave off some extra bytes, but we
could leave them out as well. The <code>-defaultpackage</code> directive moves
all classes to the given package, in this case the root package. Only
<code>proguard.ProGuard</code> keeps its original name.
<p>
In general, you might need a few additional directives for processing <a
href="#native">native methods</a>, <a href="#serializable">serializable
classes</a>, or <a href="#beans">bean classes</a>. For 'simple' applications
like ProGuard, that is not required.

<a name="applet">&nbsp;</a>
<h3>A typical applet</h3>
These options shrink and obfuscate the applet <code>mypackage.MyApplet</code>:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-libraryjars &lt;java.home&gt;/lib/rt.jar
-injars      in.jar
-outjar      out.jar

-keep public class mypackage.MyApplet
</pre>
</td></tr></table>
<p>
The typical applet methods will be preserved automatically, since
<code>mypackage.MyApplet</code> is an extension of the <code>Applet</code>
class in the library <code>rt.jar</code>.
<p>
If applicable, you should add directives for processing <a
href="#native">native methods</a>, <a href="#serializable">serializable
classes</a>, or <a href="#beans">bean classes</a>.

<a name="midlet">&nbsp;</a>
<h3>A typical midlet</h3>
These options shrink and obfuscate the J2ME midlet
<code>mypackage.MyMIDlet</code>:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-libraryjars /usr/local/java/wtk104/lib/midpapi.zip
-injars      in.jar
-outjar      out.jar

-keep public class mypackage.MyMIDlet
</pre>
</td></tr></table>
<p>
Note how we're now targeting the J2ME run-time environment
<code>midpapi.zip</code>, instead of the J2SE run-time environment
<code>rt.jar</code>.
<p>
The typical midlet methods will be preserved automatically, since
<code>mypackage.MyMIDlet</code> is an extension of the <code>MIDlet</code>
class in the library <code>midpapi.zip</code>.
<p>
If applicable, you should add directives for processing <a
href="#native">native methods</a>, <a href="#serializable">serializable
classes</a>, or <a href="#beans">bean classes</a>.
<p>
You should preverify your midlets <i>after</i> having processed them, using
J2ME's <code>preverify</code> tool.
<p>
Please note the in-depth article <a
href="http://wireless.java.sun.com/midp/ttips/proguard/">"Obfuscating MIDlet
Suites with ProGuard"</a> at <a
href="http://wireless.java.sun.com/">wireless.java.sun.com</a>.

<a name="applications">&nbsp;</a>
<h3>All possible applications in the input jars</h3>
These options shrink and obfuscate all public applications in
<code>in.jar</code>:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-libraryjars &lt;java.home&gt;/lib/rt.jar
-injars      in.jar
-outjar      out.jar
-printseeds

-keepclasseswithmembers public class * {
    public static void main(java.lang.String[]);
}
</pre>
</td></tr></table>
<p>
Note the use of <code>-keepclasseswithmembers</code>. We don't want to preserve
all classes, just all classes that have main methods, and those methods.
<p>
The <code>-printseeds</code> option prints out which classes exactly will
be preserved, so we know for sure we're getting what we want.
<p>
If applicable, you should add directives for processing <a
href="#native">native methods</a>, <a href="#serializable">serializable
classes</a>, or <a href="#beans">bean classes</a>.

<a name="applets">&nbsp;</a>
<h3>All possible applets in the input jars</h3>
These options shrink and obfuscate all public applets in <code>in.jar</code>:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-libraryjars &lt;java.home&gt;/lib/rt.jar
-injars      in.jar
-outjar      out.jar
-printseeds

-keep public class * extends java.applet.Applet
</pre>
</td></tr></table>
<p>
We're simply keeping all classes that extend the <code>Applet</code> class.
<p>
Again, the <code>-printseeds</code> option prints out which applets exactly
will be preserved.
<p>
If applicable, you should add directives for processing <a
href="#native">native methods</a>, <a href="#serializable">serializable
classes</a>, or <a href="#beans">bean classes</a>.

<a name="midlets">&nbsp;</a>
<h3>All possible midlets in the input jars</h3>
These options shrink and obfuscate all public J2ME midlets in
<code>in.jar</code>:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-libraryjars /wtk104/lib/midpapi.zip
-injars      in.jar
-outjar      out.jar
-printseeds

-keep public class * extends javax.microedition.midlet.MIDlet
</pre>
</td></tr></table>
<p>
We're simply keeping all classes that extend the <code>MIDlet</code> class.
<p>
And again, the <code>-printseeds</code> option prints out which midlets exactly
will be preserved.
<p>
If applicable, you should add directives for processing <a
href="#native">native methods</a>, <a href="#serializable">serializable
classes</a>, or <a href="#beans">bean classes</a>.
<p>
You should preverify your midlets <i>after</i> having processed them, using
J2ME's <code>preverify</code> tool.

<a name="servlets">&nbsp;</a>
<h3>All possible servlets in the input jars</h3>
These options shrink and obfuscate all public servlets in <code>in.jar</code>:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-libraryjars &lt;java.home&gt;/lib/rt.jar
-libraryjars /usr/local/java/servlet/servlet.jar
-injars      in.jar
-outjar      out.jar
-printseeds

-keep public class * implements javax.servlet.Servlet
</pre>
</td></tr></table>
<p>
Keeping all servlets is very similar to keeping all applets. The servlet API
is not part of the standard run-time jar, so we're specifying it as a library.
Don't forget to use the right path name.
<p>
We're then keeping all classes that implement the <code>Servlet</code>
interface. We're using the <code>implements</code> keyword because it looks
more familiar in this context, but it is equivalent to <code>extends</code>,
as far as ProGuard is concerned.
<p>
And again, the <code>-printseeds</code> option prints out which servlets
exactly will be preserved.
<p>
If applicable, you should add directives for processing <a
href="#native">native methods</a>, <a href="#serializable">serializable
classes</a>, or <a href="#beans">bean classes</a>.

<a name="library">&nbsp;</a>
<h3>Processing a library</h3>
These options shrink and obfuscate an entire library, keeping all public and
protected classes and class members, native method names, and serialization
code:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-libraryjars  &lt;java.home&gt;/lib/rt.jar
-injars       in.jar
-outjar       out.jar
-printmapping out.map

-renamesourcefileattribute SourceFile
-keepattributes SourceFile,LineNumberTable,Deprecated

-keep public class * {
    public protected *;
}

-keepclassmembernames class * {
    static Class class$(java.lang.String);
    static Class class$(java.lang.String, boolean);
}

-keepclasseswithmembernames class * {
    native &lt;methods&gt;;
}

-keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    Object writeReplace();
    Object readResolve();
}
</pre>
</td></tr></table>
<p>
This configuration should preserve everything we'll ever want to access in the
library. Only if there are any other non-public classes or methods that are
invoked dynamically, they should be specified using additional
<code>-keep</code> directives.
<p>
Note the use of <code>-keepclassmembernames</code> for the static
<code>class$</code> methods. These methods are inserted by the
<code>javac</code> compiler and the <code>jikes</code> compiler respectively,
to implement the <code>.class</code> construct. ProGuard will automatically
detect them and deal with them; no problem at this point. However, ProGuard
may be used again to shrink an application that uses this obfuscated library.
Without having preserved the method names, the automatic detection would fail
the second time around.
<p>
We've added some directives for keeping the "Deprecated" attribute, for <a
href="#stacktrace">useful stack traces</a>, for <a href="#native">native
methods</a>, and for <a href="#serializable">serializable classes</a>, which
are discussed in their respective examples.

<a name="native">&nbsp;</a>
<h3>Processing native methods</h3>
If your application, applet, servlet, library, etc., contains native methods,
you'll want to preserve their names and their classes' names, so they can
still be linked to the native library. The following additional option will
ensure that:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-keepclasseswithmembernames class * {
    native &lt;methods&gt;;
}
</pre>
</td></tr></table>
<p>
Note the use of <code>-keepclasseswithmembernames</code>. We don't want to
preserve all classes or all native methods; we just want to keep the relevant
names from being obfuscated.

<a name="serializable">&nbsp;</a>
<h3>Processing serializable classes</h3>
More complex applications, applets, servlets, libraries, etc., may contain
classes that are serialized. Depending on the way in which they are used, they
may require special attention:
<ul>

<li>Often, serialization is simply a means of transporting data, without
    long-term storage. Classes that are shrunk and obfuscated should then
    continue to function fine with the following additional directives:

<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-keepclassmembers class * implements java.io.Serializable {
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    Object writeReplace();
    Object readResolve();
}
</pre>
</td></tr></table>
<p>

    The <code>-keepclassmembers</code> option makes sure that any
    serialization methods are kept. By using this directive instead of the
    basic <code>-keep</code> directive, we're not forcing preservation of
    <i>all</i> serializable classes, just preservation of the listed members
    of classes that are actually used.
    <p>

<li>Sometimes, the serialized data are stored, and read back later into newer
    versions of the serializable classes. One then has to take care the classes
    remain compatible with their unprocessed versions and with future
    processed versions. In such cases, the relevant classes will most likely
    have <code>serialVersionUID</code> fields. The following directives should
    then be sufficient to ensure compatibility over time:

<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-keepnames class * implements java.io.Serializable

-keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
    !static !transient &lt;fields&gt;;
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    Object writeReplace();
    Object readResolve();
}
</pre>
</td></tr></table>
<p>

    The <code>serialVersionUID</code> line makes sure that field is preserved.
    The <code>&lt;fields&gt;</code> line preserves all non-static,
    non-transient fields, with their original names. The introspection of the
    serialization process and the de-serialization process will then find
    consistent names.

<li>Occasionally, the serialized data have to remain compatible, but the
    classes involved lack <code>serialVersionUID</code> fields. I imagine the
    original code will then be hard to maintain, since the serial version UID
    is then computed from a list of features the serializable class. Changing
    the class ever so slightly may change the computed serial version UID. The
    list of features is specified in the chapter on <a
    href="http://java.sun.com/j2se/1.4/docs/guide/serialization/spec/class.doc6.html">Stream
    Unique Identifiers</a> of Sun's <a
    href="http://java.sun.com/j2se/1.4/docs/guide/serialization/">Object
    Serialization Guide</a>. The following directives should at least
    partially ensure compatibility with the original classes

<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-keepnames class * implements java.io.Serializable

-keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
    !static !transient &lt;fields&gt;;
    !private &lt;fields&gt;;
    !private &lt;methods&gt;;
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    Object writeReplace();
    Object readResolve();
}
</pre>
</td></tr></table>
<p>

    The new directives force preservation of the elements involved in the UID
    computation. In addition, the user will have to manually specify all
    interfaces of the serializable classes (using something like "<code>-keep
    interface MyInterface</code>"), since these names are also used when
    computing the UID. A fast but sub-optimal alternative would be simply
    keeping all interfaces with "<code>-keep interface *</code>".

</ul>
<p>

Note that the above directives may preserve more classes and class members
than strictly necessary. For instance, a large number of classes may implement
the <code>Serialization</code> interface, yet only a small number may actually
ever be serialized. Knowing your application and tuning the configuration will
often produce more compact results.

<a name="beans">&nbsp;</a>
<h3>Processing bean classes</h3>
If your application, applet, servlet, library, etc., uses extensive
introspection on bean classes to find bean editor classes, or getter and
setter methods, then configuration may become laborious. There's not much else
you can do than making sure the bean class names, or the getter and setter
names don't change. For instance:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-keep public class mypackage.MyBean {
    public void setMyProperty(int);
    public int getMyProperty();
}

-keep public class mypackage.MyBeanEditor
</pre>
</td></tr></table>

<a name="stacktrace">&nbsp;</a>
<h3>Producing useful obfuscated stack traces</h3>
These options let obfuscated applications or libraries produce stack traces
that can still be deciphered later on:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-printmapping out.map

-renamesourcefileattribute SourceFile
-keepattributes SourceFile,LineNumberTable
</pre>
</td></tr></table>
<p>
We're keeping all source file attributes, but we're replacing their values by
the string "SourceFile". We could use any string. This string is already
present in all class files, so it doesn't take up any extra space.
<p>
We're also keeping the line number tables of all methods.
<p>
Whenever both of these attributes are present, the Java run-time environment
will include line number information when printing out exception stack traces.
<p>
The information will only be useful if we can map the obfuscated names back to
their original names, so we're saving the mapping to a file
<code>out.map</code>. The information can then be used by the <a
href="retrace.html">ReTrace</a> tool to restore the original stack trace.

<a name="deadcode">&nbsp;</a>
<h3>Finding dead code</h3>
These options list unused fields and methods in the application
<code>mypackage.MyApplication</code>:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-libraryjars &lt;java.home&gt;/lib/rt.jar
-injars      in.jar
-dontobfuscate
-printusage

-keep public class mypackage.MyApplication {
    public static void main(java.lang.String[]);
}
</pre>
</td></tr></table>
<p>
We're not specifying an output jar, just printing out some results.
<p>
We're saving a little bit of time by not passing through the obfuscation phase.

<a name="structure">&nbsp;</a>
<h3>Printing out the internal structure of class files</h3>
These options print out the internal structure of all class files in the input
jar:
<table width="90%" cellpadding="10"><tr><td bgcolor="#E0E0E0">
<pre>
-injars in.jar
-dontwarn
-dontnote
-dontshrink
-dontobfuscate
-dump
</pre>
</td></tr></table>
<p>
Note how we don't need to specify the Java run-time jar, because we're not
processing the input jar at all. In this case, we can safely ignore any
warnings about unresolved references, so we use the <code>-dontwarn</code>
option. We're also not interested in any advice about dynamic invocations,
so we use the <code>-dontnote</code> option.
<p>

<hr>
<address>
Copyright &copy; 2002 <a href="http://www.graphics.cornell.edu/~eric/">Eric
Lafortune</a>.
</address>
</body>
</html>
